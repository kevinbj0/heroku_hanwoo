# -*- coding: utf-8 -*-
"""LangGraph_1030_발표용.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p_TI_5ze1trcQ4Ep320SMJ29wTitNZI2
"""

import os
from dotenv import load_dotenv

# 환경변수 로드
load_dotenv()

# API 키를 환경변수에서 가져옴
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

import psycopg2
import pandas as pd
import logging
from typing import TypedDict, Annotated, Sequence, Optional
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langgraph.graph import StateGraph, END, START
import operator
from fuzzywuzzy import fuzz, process
import re
import os
import uuid
import json
from openai import OpenAI
from langsmith import Client
from langsmith.run_trees import RunTree
from datetime import datetime


# 기존 imports 유지하고 FastAPI 관련 import 추가
from fastapi import FastAPI
from pydantic import BaseModel
import uvicorn

# FastAPI 앱 초기화
app = FastAPI()


# 간단한 요청 모델
class ChatInput(BaseModel):
    message: str

# 전역 변수로 필요한 객체들 선언
app_state = None
customer_conn = None
customer_cursor = None
hanwoo_conn = None
hanwoo_cursor = None
workflow = None

# 로깅 설정
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# 상수 정의
CUTS = ['티본', '안심', '상등심', '하등심', '윗등심', '아래등심', '아랫등심', '꾸리덮개살', '사태', '뒷사태',
        '앞사태', '상박아롱사태', '멍에덮개살', '모듬육', '목심', '알목심', '목심외', '목양지', '부채살',
        '살치살', '설깃', '도가니살', '설깃살', '보섭살', '삼각살', '설도', '앞다리', '앞다리살', '양지',
        '양지머리', '업진양지', '치마양지', '업진살', '우둔', '짝갈비', '차돌박이', '탕갈비', '대갈비',
        '갈비세트', '갈비양지', '갈비뼈', '보신세트', '갈비모듬육', '갈비지방', '재공품', '설깃머리살',
        '알함박', '우둔덮개살', '함박지방']

BREEDS = {
    '암소': ['암소', '앙소', '암'],
    '거세': ['거세', '거새', '거']
}

GRADES = {
    '투뿔9번': ['투뿔9번', '투뿔 9번', '투플9번', '투플 9번', '9번', '구번', '9', '구',
               '투뿔구번', '투플구번', '투뿔 구번', '투플 구번', '투뿔 9', '투플 9',
               '투뿔9', '투플9', '투뿔 구', '투플 구', '투뿔구', '투플구'],
    '투뿔8번': ['투뿔8번', '투뿔 8번', '투플8번', '투플 8번', '8번', '팔번', '8', '팔',
               '투뿔팔번', '투플팔번', '투뿔 팔번', '투플 팔번', '투뿔 8', '투플 8',
               '투뿔8', '투플8', '투뿔 팔', '투플 팔', '투뿔팔', '투플팔'],
    '투뿔7번': ['투뿔7번', '투뿔 7번', '투플7번', '투플 7번', '7번', '칠번', '7', '칠',
               '투뿔칠번', '투플칠번', '투뿔 칠번', '투플 칠번', '투뿔 7', '투플 7',
               '투뿔7', '투플7', '투뿔 칠', '투플 칠', '투뿔칠', '투플칠'],
    '원뿔': ['원뿔', '원플', '1+', '1+등급', '1플러스', '원플러스', '원뿔등급',
           '원플등급', '1플러스등급'],
    '1등급': ['1등급', '1급', '일등급', '1', '일급', '일번등급', '일번', '1번등급', '1번'],
    '2등급': ['2등급', '2급', '이등급', '2', '이급', '이번등급', '이번', '2번등급', '2번'],
    '3등급': ['3등급', '3급', '삼등급', '3', '삼급', '삼번등급', '삼번', '3번등급', '3번']
}

COMPLEX_CUTS = {
    '갈비 양지': '갈비양지',
    '갈비양지': '갈비양지',
    '함박 지방': '함박지방',
    '함박지방': '함박지방',
    '멍에 덮개살': '멍에덮개살',
    '멍에덮개살': '멍에덮개살',
    '꾸리 덮개살': '꾸리덮개살',
    '꾸리덮개살': '꾸리덮개살',
    '우둔 덮개살': '우둔덮개살',
    '우둔덮개살': '우둔덮개살',
    '상박 아롱사태': '상박아롱사태',
    '상박아롱사태': '상박아롱사태',
    '설깃 머리살': '설깃머리살'
}

PRE_MAPPING = {
    '압사태': '앞사태',
    '상바가롱사태': '상박아롱사태',
    '멍에덮개': '멍에덮개살',
    '꾸리덮개': '꾸리덮개살',
    '우둔덮개': '우둔덮개살',
    '설깃머리': '설깃머리살',
}

SELECTION_INTENTS = [
    # 기본 구매 의도
    "할게요", "주문", "구매", "살게요", "구입", "할래요",
    # 지시 표현
    "이걸로", "그걸로", "저걸로", "해줘", "해주세요", "부탁해요",
    # 긍정 표현
    "좋아요", "좋네요", "괜찮아요", "잘", "됐", "했",
    # 선택 조사
    "으로", "로", "으루", "루",
    # 한국어 특성 반영
    "이요", "요", "이거요", "그거요", "저거요",
    "이거", "그거", "저거",
    "이것", "저것", "그것",
    "이", "이게", "이번", "번"
]

# 긍정 답변 모음
POSITIVE_RESPONSES = [
    "네", "예", "좋", "그래", "알겠", "해주", "할게", "그렇게", "맞", "응",
    "괜찮", "그래요", "ok", "넵", "당연", "주세요"
]
# 부정 답변 모음
NEGATIVE_RESPONSES = [
    "아니", "안", "못", "싫", "no", "취소", "그만"
]
# 주문 의도 모음
order_intentions = [
    "주문", "구매", "살게요", "구입", "할게요", "해주세요",
    "부탁해요", "주세요", "할래요", "알겠습니다"
]
# 수령 방법 모음
DELIVERY_METHODS = [
    "배송", "택배", "청주공장방문", "영천공장방문", "본사방문"
]

# Langsmith 설정
LANGSMITH_API_KEY = os.getenv("LANGSMITH_API_KEY")  # 환경변수에서 가져오기
os.environ["LANGCHAIN_API_KEY"] = LANGSMITH_API_KEY
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_PROJECT"] = "hanwoo-chatbot"
os.environ["LANGCHAIN_ENDPOINT"] = "https://api.smith.langchain.com"  # 엔드포인트 추가

client = Client()


# State 추적을 위한 데코레이터
def track_state(func):
    def wrapper(state):
        try:
            start_time = datetime.now()

            # 함수 실행 및 결과 저장
            start_time = datetime.now()
            result = func(state)

            # 실행 결과 Langsmith에 기록
            try:
                # UUID를 사용하여 고유 ID 생성
                run_id = str(uuid.uuid4())

                client.create_run(
                    name="conversation_state",
                    run_type="chain",
                    inputs={
                        "conversation_stage": state["conversation_stage"],
                        "last_message": state["messages"][-1].content if state["messages"] else "",
                        "customer_info": str(state["customer_info"]),
                        "meat_selection": str(state["meat_selection"]),
                        "selected_item": str(state.get("selected_item")),
                        "orders": str(state.get("orders", []))
                    },
                    outputs={
                        "new_stage": result["conversation_stage"],
                        "response": result["messages"][-1].content if result["messages"] else "",
                        "updated_customer_info": str(result["customer_info"]),
                        "updated_meat_selection": str(result["meat_selection"]),
                        "updated_selected_item": str(result.get("selected_item")),
                        "updated_orders": str(result.get("orders", [])),
                        "execution_time": str(datetime.now() - start_time)
                    },
                    run_id=run_id,  # UUID 사용
                    project_name="hanwoo-chatbot",
                    start_time=start_time,
                    end_time=datetime.now()
                )
            except Exception as e:
                logging.error(f"Langsmith 추적 오류: {str(e)}")
                pass

            return result

        except Exception as e:
            logging.error(f"함수 실행 오류: {str(e)}")
            try:
                error_run_id = str(uuid.uuid4())
                client.create_run(
                    name="conversation_state",
                    run_type="chain",
                    inputs={
                        "conversation_stage": state["conversation_stage"],
                        "error": str(e)
                    },
                    error=str(e),
                    run_id=error_run_id,
                    project_name="hanwoo-chatbot",
                    start_time=datetime.now(),
                    end_time=datetime.now()
                )
            except:
                pass
            raise e

    return wrapper

# langsmith 대화 기록 분석
def analyze_conversation_history(project_name="hanwoo-chatbot", limit=100):
    """대화 기록 분석"""
    try:
        # Langsmith에서 대화 기록 조회
        runs = client.list_runs(
            project_name=project_name,
            execution_order=1,
            limit=limit
        )

        statistics = {
            "total_conversations": 0,
            "average_response_time": 0,
            "stage_transitions": {},
            "error_rate": 0,
            "total_errors": 0
        }

        total_time = 0
        if runs:  # runs가 None이 아닌 경우에만 처리
            for run in runs:
                try:
                    statistics["total_conversations"] += 1

                    # 응답 시간 계산
                    outputs = getattr(run, 'outputs', {}) or {}
                    if isinstance(outputs, dict) and 'execution_time' in outputs:
                        try:
                            exec_time = float(outputs['execution_time'].split(':')[-1].strip())
                            total_time += exec_time
                        except (ValueError, AttributeError):
                            pass

                    # 상태 전환 분석
                    inputs = getattr(run, 'inputs', {}) or {}
                    if isinstance(outputs, dict) and isinstance(inputs, dict):
                        old_stage = inputs.get("conversation_stage", "unknown")
                        new_stage = outputs.get("new_stage")
                        if new_stage:  # new_stage가 None이 아닌 경우에만 처리
                            transition_key = f"{old_stage}->{new_stage}"
                            statistics["stage_transitions"][transition_key] = statistics["stage_transitions"].get(transition_key, 0) + 1

                    # 오류 확인
                    if getattr(run, 'error', None):
                        statistics["total_errors"] += 1

                except Exception as e:
                    logging.error(f"개별 대화 분석 중 오류 발생: {str(e)}")
                    continue

            # 통계 계산
            if statistics["total_conversations"] > 0:
                statistics["average_response_time"] = total_time / statistics["total_conversations"]
                statistics["error_rate"] = statistics["total_errors"] / statistics["total_conversations"]

        return statistics

    except Exception as e:
        logging.error(f"대화 기록 분석 중 오류 발생: {str(e)}")
        # 오류 발생 시 기본 통계 반환
        return {
            "total_conversations": 0,
            "average_response_time": 0,
            "stage_transitions": {},
            "error_rate": 0,
            "total_errors": 0
        }


# 상태 정의
class State(TypedDict):
    messages: Annotated[Sequence[BaseMessage], operator.add]
    conversation_stage: str
    customer_info: Optional[dict]
    meat_selection: Optional[list[dict]] # 조회 품목 중 추천한 3가지
    selected_item: Optional[dict]  # 고객이 선택한 품복 정보
    order_info: Optional[dict]  # 주문 정보 추가
    orders: Optional[list[dict]]  # 여러 주문을 관리하기 위한 리스트
    delivery_method: Optional[str]  # 수령 방법 정보


# 대화 단계 상태 정의
class ConversationStage:
    INIT = "init"
    CUSTOMER_RECOGNITION = "customer_recognition"
    MEAT_SELECTION = "meat_selection"
    SELECTION_DISAMBIGUATION = "selection_disambiguation"
    ORDER_CONFIRMATION = "order_confirmation"
    WEIGHT_CONFIRMATION = "weight_confirmation"  # 중량 확인 단계
    RESERVATION_CONFIRMATION = "reservation_confirmation"  # 예약 주문 확인 단계
    ADDITIONAL_ORDER_CONFIRMATION = "additional_order_confirmation"  # 추가 주문 확인 단계
    DELIVERY_METHOD_SELECTION = "delivery_method_selection"  # 수령 방법 선택 단계


# 데이터베이스 초기화 및 연결
def init_databases():
    # PostgreSQL 연결 설정
    customer_conn = psycopg2.connect(
        host=os.getenv("host"),
        database=os.getenv("database"),
        user=os.getenv("user"),
        password=os.getenv("password")
    )
    customer_cursor = customer_conn.cursor()
 
    # 한우 데이터베이스
    hanwoo_conn = psycopg2.connect(
        host=os.getenv("host"),
        database=os.getenv("database"),
        user=os.getenv("user"),
        password=os.getenv("password")
    )
    hanwoo_cursor = hanwoo_conn.cursor()
 
    return (customer_conn, customer_cursor), (hanwoo_conn, hanwoo_cursor)
 
# 유틸리티 함수들
def is_positive_response(message):
    """
    메시지가 긍정적인 응답인지 판단
    """
    message = message.lower()
    return any(pos in message for pos in POSITIVE_RESPONSES) or not any(neg in message for neg in NEGATIVE_RESPONSES)

def is_negative_response(message):
    """
    메시지가 부정적인 응답인지 판단
    """
    message = message.lower()
    return any(neg in message for neg in NEGATIVE_RESPONSES)

# 이름 매핑 함수
def map_name(input_text, name_list):
    input_text = input_text.lower().strip()
    input_words = re.findall(r'\w+', input_text)
    possible_names = [' '.join(input_words[i:i+j]) for i in range(len(input_words)) for j in range(1, len(input_words)-i+1)]
    possible_names += [''.join(name.split()) for name in possible_names]
    logging.debug(f"입력에서 추출된 가능한 이름들: {possible_names}")

    best_match = None
    best_score = 0

    for name in possible_names:
        matches = process.extract(name, name_list, limit=5, scorer=fuzz.ratio)
        logging.debug(f"'{name}'에 대한 매칭 결과: {matches}")

        for match, score in matches:
            if len(name.split()) > 1:
                score += 10

            if score > best_score:
                best_score = score
                best_match = match

            if score >= 80:
                logging.info(f"'{name}'을(를) '{match}'로 매핑함 (점수: {score})")
                return match
            elif score >= 70:
                partial_score = fuzz.partial_ratio(name, match)
                if partial_score >= 90:
                    logging.info(f"'{name}'을(를) '{match}'로 매핑함 (점수: {score}, 부분 일치: {partial_score})")
                    return match

    if best_match:
        logging.info(f"최고 매칭 결과: '{best_match}' (점수: {best_score})")
        return best_match

    logging.warning(f"입력에 대한 적절한 매칭을 찾을 수 없음: '{input_text}'")
    return None

# 입력 매핑 함수
def map_input(input_text):
    input_text = input_text.lower().strip()
    mapped_cut = None
    mapped_breed = None
    mapped_grade = None

    # 복합 단어 처리
    for complex_cut, mapped in COMPLEX_CUTS.items():
        if complex_cut in input_text:
            mapped_cut = mapped
            input_text = input_text.replace(complex_cut, '')
            break

    # 사전 매핑 처리
    for pre_map, mapped in PRE_MAPPING.items():
        if pre_map in input_text:
            mapped_cut = mapped
            input_text = input_text.replace(pre_map, '')
            break

    # 부위 매칭
    if not mapped_cut:
        for cut in CUTS:
            if cut in input_text:
                mapped_cut = cut
                input_text = input_text.replace(cut, '')
                break

    # 등급 매핑
    for grade, variations in GRADES.items():
        for variation in variations:
            # 공백을 제거한 버전과 포함한 버전 모두 체크
            no_space_variation = variation.replace(' ', '')
            no_space_input = input_text.replace(' ', '')

            # 완전 일치 검사
            if (variation.lower() == input_text.strip() or
                no_space_variation.lower() == no_space_input.strip()):
                mapped_grade = grade
                input_text = ''
                break

            # 부분 일치 검사
            elif (variation.lower() in input_text or
                  no_space_variation.lower() in no_space_input):
                mapped_grade = grade
                # 매칭된 부분 제거
                input_text = input_text.replace(variation.lower(), '')
                input_text = input_text.replace(no_space_variation.lower(), '')
                break
        if mapped_grade:
            break

    # 축종 매핑
    for breed, variations in BREEDS.items():
        for variation in variations:
            if variation in input_text:
                mapped_breed = breed
                input_text = input_text.replace(variation, '')
                break
        if mapped_breed:
            break

    return mapped_cut, mapped_breed, mapped_grade

# 예약 의도 분류 (LLM 판단)
class ReservationIntentClassifier:
    def __init__(self):
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    def classify_intent(self, customer_message, context):
        """
        고객 메시지의 의도를 분류합니다.
        """
        prompt = f"""
        주문 상황:
        - 고객이 요청한 총 중량: {context['requested_weight']}kg
        - 현재 가능한 중량: {context['immediate_weight']}kg
        - kg당 가격: {context['price_per_kg']:,}원

        고객 메시지: "{customer_message}"

        위 상황에서 고객의 의도를 다음 세 가지 중 하나로 분류해주세요:
        1. full_order: 현재 재고와 부족분을 예약주문으로 모두 주문
        2. immediate_only: 현재 있는 재고만 주문
        3. new_selection: 다른 상품을 새로 찾기를 원함

        다음 형식으로 답변해주세요:
        intent: (의도)
        confidence: (0~1 사이의 신뢰도)
        reasoning: (판단 근거)
        """

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "당신은 한우 판매점의 고객 의도를 분석하는 전문가입니다."},
                    {"role": "user", "content": prompt}
                ]
            )

            # 응답 텍스트 파싱
            response_text = response.choices[0].message.content

            # 응답을 파싱하여 딕셔너리로 변환
            lines = response_text.strip().split('\n')
            result = {}
            for line in lines:
                if ':' in line:
                    key, value = line.split(':', 1)
                    result[key.strip().lower()] = value.strip()

            # confidence를 float로 변환
            if 'confidence' in result:
                try:
                    result['confidence'] = float(result['confidence'])
                except ValueError:
                    result['confidence'] = 0.5

            return result

        except Exception as e:
            logging.error(f"의도 분류 중 오류 발생: {str(e)}")
            return {"intent": "unclear", "confidence": 0, "reasoning": str(e)}


def get_response_by_intent(intent_result, order_info):
    """분류된 의도에 따른 응답을 생성합니다."""

    if intent_result['confidence'] < 0.7:
        return {
            "messages": [AIMessage(content=f"""
고객님의 의견을 정확히 파악하지 못했습니다. 아래 선택지 중에서 말씀해 주시겠습니까?

1. 현재 재고 {order_info['immediate_weight']:.1f}kg와 부족분 {order_info['reservation_weight']:.1f}kg 예약주문 모두 진행
2. 현재 재고 {order_info['immediate_weight']:.1f}kg만 주문
3. 다른 상품 찾아보기
            """.strip())],
            "conversation_stage": ConversationStage.RESERVATION_CONFIRMATION,
            "order_info": order_info
        }

    if intent_result['intent'] == 'full_order':
        # 전체 주문 (즉시 + 예약)
        total_price = order_info['immediate_price'] + order_info['reservation_price']
        confirmation_msg = (
            f"네, 고객님. 현재 재고 {order_info['immediate_weight']:.1f}kg는 바로 구매해드리고, "
            f"나머지 {order_info['reservation_weight']:.1f}kg는 예약주문으로 진행하겠습니다.\n\n"
            f"총 결제금액: {total_price:,}원입니다.\n"
            f"예약주문은 입고 시 연락드리겠습니다."
        )
        return {
            "messages": [AIMessage(content=confirmation_msg)],
            "conversation_stage": ConversationStage.ADDITIONAL_ORDER_CONFIRMATION,
            "order_info": {
                **order_info,
                "confirmed": True,
                "type": "split",
                "total_price": total_price,
                "selected_item": order_info.get("selected_item", {})
            }
        }

    elif intent_result['intent'] == 'immediate_only':
        # 현재 재고만 주문
        confirmation_msg = (
            f"네, 고객님. 현재 보유 재고 {order_info['immediate_weight']:.1f}kg만 주문 진행하겠습니다.\n"
            f"결제 금액: {order_info['immediate_price']:,}원입니다."
        )
        return {
            "messages": [AIMessage(content=confirmation_msg)],
            "conversation_stage": ConversationStage.ADDITIONAL_ORDER_CONFIRMATION,
            "order_info": {
                **order_info,
                "confirmed": True,
                "type": "immediate",
                "total_price": order_info['immediate_price'],
                "selected_item": order_info.get("selected_item", {})
            }
        }

    elif intent_result['intent'] == 'new_selection':
        return {
            "messages": [AIMessage(content="네, 고객님. 다시 원하시는 상품을 말씀해 주세요.")],
            "conversation_stage": ConversationStage.MEAT_SELECTION,
            "order_info": {}
        }

    else:
        return {
            "messages": [AIMessage(content=f"""
죄송합니다. 고객님의 의견을 정확히 파악하지 못했습니다.
현재 가능한 선택지를 다시 한 번 말씀드리겠습니다:

1. 전체 주문 (현재 재고 {order_info['immediate_weight']:.1f}kg + 예약 {order_info['reservation_weight']:.1f}kg)
2. 현재 재고 {order_info['immediate_weight']:.1f}kg만 주문
3. 다른 상품 찾아보기

어떻게 진행해 드릴까요?
            """.strip())],
            "conversation_stage": ConversationStage.RESERVATION_CONFIRMATION,
            "order_info": order_info
        }

# 고객 정보 조회 함수
def query_customer_info(input_text):
    try:
        customer_cursor.execute("SELECT 고객명, 상호명 FROM customers")
        all_names = [item for sublist in customer_cursor.fetchall() for item in sublist if item]

        mapped_name = map_name(input_text, all_names)
        logging.debug(f"매핑된 이름: {mapped_name}")

        if mapped_name:
            # 컬럼명 수정
            customer_cursor.execute("""
                SELECT 고객명, 상호명, 연령대, 성별, 주소, 마지막_주문일자, 주로_사는_부위
                FROM customers
                WHERE 고객명 LIKE %s OR 상호명 LIKE %s
            """, (f'%{mapped_name}%', f'%{mapped_name}%'))

            result = customer_cursor.fetchone()
            if result:
                return {
                    "고객명": result[0],
                    "상호명": result[1],
                    "연령대": result[2],
                    "성별": result[3],
                    "주소": result[4],
                    "마지막_주문일자": result[5],
                    "주로_사는_부위": result[6]
                }
    except Exception as e:
        logging.error(f"고객 정보 조회 중 오류 발생: {str(e)}")
    return None

# 고기 정보 조회 함수
def query_meat_info(input_text):
    try:
        mapped_cut, mapped_breed, mapped_grade = map_input(input_text)
        logging.debug(f"매핑된 값 - 부위: {mapped_cut}, 축종: {mapped_breed}, 등급: {mapped_grade}")

        conditions = []
        params = []

        if mapped_cut:
            conditions.append("부위 = %s")
            params.append(mapped_cut)
        if mapped_breed:
            conditions.append("축종 = %s")
            params.append(mapped_breed)
        if mapped_grade:
            conditions.append("등급명 = %s")
            params.append(mapped_grade)

        conditions.append("재고없음 = '0'")

        where_clause = " AND ".join(conditions) if conditions else "1=1"
        sql_query = f"""
            SELECT 부위, 축종, 등급명, "판매단가(원/g)", "중량(kg)"
            FROM hanwoo
            WHERE {where_clause}
            ORDER BY "판매단가(원/g)" ASC
            LIMIT 3  /* 상위 3개로 제한 */
        """

        hanwoo_cursor.execute(sql_query, params)
        results = hanwoo_cursor.fetchall()

        if results:
            return [
                {
                    "부위": row[0],
                    "축종": row[1],
                    "등급": row[2],
                    "가격": int(float(row[3]) * 1000),  # g당 가격을 kg당 가격으로 변환
                    "재고": float(row[4])
                }
                for row in results
            ]

    except Exception as e:
        logging.error(f"고기 정보 조회 중 오류 발생: {str(e)}")
    return None


# 주문 파싱 함수
def parse_order(message, available_items, previous_messages=None):
    message = message.lower()
    has_selection_intent = any(intent in message for intent in SELECTION_INTENTS)

    # 이전 대화 내용에서 언급된 상품 정보 추출
    mentioned_info = {
        'part': None,
        'breed': None,
        'grade': None
    }

    if previous_messages:
        for prev_msg in previous_messages:
            if isinstance(prev_msg, AIMessage):
                # AI 응답에서 언급된 상품 정보 추출
                for item in available_items:
                    if item['부위'] in prev_msg.content and item['축종'] in prev_msg.content and item['등급'] in prev_msg.content:
                        mentioned_info['part'] = item['부위']
                        mentioned_info['breed'] = item['축종']
                        mentioned_info['grade'] = item['등급']
                        break

    # 현재 메시지에 주문 의도가 있는지 확인
    has_order_intention = any(intent in message for intent in order_intentions)

    best_match = None
    best_match_score = 0

    for item in available_items:
        score = 0

        # 1. 직접적인 언급 확인
        if item['부위'].lower() in message:
            score += 3
        if item['축종'].lower() in message:
            score += 2
        if item['등급'].lower().replace(' ', '') in message.replace(' ', ''):
            score += 2

        # 2. 이전 대화에서 언급된 정보와 매칭
        if mentioned_info['part'] == item['부위']:
            score += 2
        if mentioned_info['breed'] == item['축종']:
            score += 1
        if mentioned_info['grade'] == item['등급']:
            score += 1

        # 3. 부분 일치나 유사도 검사
        part_words = item['부위'].lower().split()
        if any(word in message for word in part_words):
            score += 1

        # 최고 점수 업데이트
        if score > best_match_score:
            best_match_score = score
            best_match = item

    # 주문 의도가 있고 충분한 매칭 점수가 있는 경우
    if has_order_intention and best_match_score >= 3:
        return best_match

    # 명확한 상품 언급이 있는 경우
    if best_match_score >= 5:
        return best_match

    return None

#사용자 요청 고기 확정 매칭
def find_ambiguous_selections(message, previous_items):
    """사용자 입력과 일치하는 여러 항목을 찾아 반환"""
    message = message.lower()
    matched_items = []

    # SELECTION_INTENTS 상수 사용
    has_selection_intent = any(intent in message for intent in SELECTION_INTENTS)
    if not has_selection_intent:
        return []

    for item in previous_items:
        score = 0
        if item['등급'].lower() in message:
            score += 3
        if item['축종'].lower() in message:
            score += 2
        if item['부위'].lower() in message:
            score += 2

        if score >= 3:
            matched_items.append(item)

    return matched_items


# 중량 추출 함수 추가
def extract_weight(message):
    # 한글 숫자 매핑
    korean_numbers = {
        '일': '1', '이': '2', '삼': '3', '사': '4', '오': '5',
        '육': '6', '칠': '7', '팔': '8', '구': '9', '십': '10',
        '열': '10'
    }

    # 한글 숫자를 아라비아 숫자로 변환
    for kor, num in korean_numbers.items():
        message = message.replace(kor, num)

    # 숫자와 단위(kg, 키로 등) 추출
    pattern = r'(\d+\.?\d*)\s*(kg|키로|킬로)?'
    match = re.search(pattern, message.lower())

    if match:
        return float(match.group(1))
    return None


# 대화 처리 함수
@track_state
def process_conversation(state):
    try:
        current_stage = state["conversation_stage"]
        messages = state["messages"]
        last_message = messages[-1].content if messages else ""
        customer_info = state["customer_info"]
        meat_selection = state["meat_selection"]
        selected_item = state.get("selected_item")
        order_info = state.get("order_info", {})
        orders = state.get("orders", [])

        if current_stage == ConversationStage.INIT:
            # INIT 단계에서도 바로 고객 정보 확인 시도
            customer_info = query_customer_info(last_message)
            if customer_info:
                response = f"""네, {customer_info['상호명']} {customer_info['고객명']} 고객님. 원하시는 고기가 있으실까요? 예. 안심 거세 1등급과 같이 말씀해주세요."""
                return {
                    "messages": messages + [AIMessage(content=response)],
                    "conversation_stage": ConversationStage.MEAT_SELECTION,
                    "customer_info": customer_info,
                    "meat_selection": None
                }
            else:
                return {
                    "messages": messages + [AIMessage(content="안녕하세요, 일품한우입니다. 고객님의 상호명이나 성함을 말씀해주세요.")],
                    "conversation_stage": ConversationStage.CUSTOMER_RECOGNITION,
                    "customer_info": None,
                    "meat_selection": None,
                    "selected_item": None,
                    "order_info": {},
                    "orders": []
                }

        elif current_stage == ConversationStage.CUSTOMER_RECOGNITION:
            customer_info = query_customer_info(last_message)
            if customer_info:
                response = f"""네, {customer_info['상호명']} {customer_info['고객명']} 고객님. 원하시는 고기가 있으실까요? 예. 안심 거세 1등급과 같이 말씀해주세요."""
                return {
                    "messages": messages + [AIMessage(content=response)],
                    "conversation_stage": ConversationStage.MEAT_SELECTION,
                    "customer_info": customer_info,
                    "meat_selection": None
                }
            else:
                return {
                    "messages": messages + [AIMessage(content="죄송합니다. 고객정보를 찾을 수 없습니다. 다시 한 번 확인해주시겠습니까?")],
                    "conversation_stage": ConversationStage.CUSTOMER_RECOGNITION,
                    "customer_info": None,
                    "meat_selection": None
                }

        elif current_stage == ConversationStage.MEAT_SELECTION:
            if meat_selection:
                mapped_cut, mapped_breed, mapped_grade = map_input(last_message)

                # 선택 의도 확인
                has_selection_intent = any(intent in last_message.lower() for intent in SELECTION_INTENTS)

                # 매칭되는 상품 찾기
                matching_items = []
                for item in meat_selection:
                    score = 0

                    # 등급 매칭 (가장 중요)
                    if mapped_grade:
                        if item['등급'] == mapped_grade:
                            score += 4
                        # 부분 일치도 확인 (예: "8번"이 "투뿔8번"과 매칭)
                        elif mapped_grade in item['등급'] or item['등급'] in mapped_grade:
                            score += 3

                    # 축종 매칭
                    if mapped_breed:
                        if item['축종'] == mapped_breed:
                            score += 2
                        elif mapped_breed in item['축종']:
                            score += 1

                    # 부위 매칭
                    if mapped_cut:
                        if item['부위'] == mapped_cut:
                            score += 2
                        elif mapped_cut in item['부위']:
                            score += 1

                    # 등급명만 말했을 때도 매칭되도록
                    grade_only = last_message.replace('으로', '').replace('로', '').strip()
                    if (grade_only in item['등급'] or
                        item['등급'].replace(' ', '') in grade_only.replace(' ', '')):
                        score += 3

                    # 이전 검색 결과와의 연관성
                    if item in meat_selection:
                        score += 1

                    if (score >= 3 or  # 일반적인 매칭
                        (has_selection_intent and score >= 2)):  # 선택 의도가 있는 경우 더 낮은 점수도 허용
                        matching_items.append(item)

                # for 루프 밖에서 처리
                if len(matching_items) == 1:
                    selected_item = matching_items[0]
                    confirmation_msg = (
                        f"네, 부위 : {selected_item['부위']}, 축종 : {selected_item['축종']}, "
                        f"등급명 : {selected_item['등급']} 로 준비해드릴까요?"
                    )
                    return {
                        "messages": messages + [AIMessage(content=confirmation_msg)],
                        "conversation_stage": ConversationStage.ORDER_CONFIRMATION,
                        "customer_info": customer_info,
                        "meat_selection": meat_selection,
                        "selected_item": selected_item,
                        "order_info": {},
                        "orders": orders
                    }
                elif len(matching_items) > 1:
                    # 모호한 선택이 있는 경우
                    response_parts = ["말씀하신 조건에 맞는 상품이 여러 개 있습니다."]
                    for idx, item in enumerate(matching_items, 1):
                        response_parts.append(
                            f"{idx}. {item['등급']} {item['축종']} {item['부위']}, "
                            f"kg당 {item['가격']:,}원 (재고: {item['재고']}kg)"
                        )
                    response_parts.append("\n원하시는 상품의 번호나 정확한 내용을 말씀해 주세요.")

                    return {
                        "messages": messages + [AIMessage(content="\n".join(response_parts))],
                        "conversation_stage": ConversationStage.SELECTION_DISAMBIGUATION,
                        "customer_info": customer_info,
                        "meat_selection": new_meat_info,
                        "selected_item": None,        # <- 추가
                        "order_info": {},            # <- 추가
                        "orders": orders             # <- 추가
                    }
                else:  # 매칭되는 항목이 없는 경우 추가
                    return {
                        "messages": messages + [AIMessage(content="죄송합니다. 원하시는 상품을 좀 더 자세히 말씀해 주시겠습니까?")],
                        "conversation_stage": ConversationStage.MEAT_SELECTION,
                        "customer_info": customer_info,
                        "meat_selection": new_meat_info,
                        "selected_item": None,
                        "order_info": {},
                        "orders": orders
                    }

            # 2. 새로운 검색 시도
            new_meat_info = query_meat_info(last_message)
            if new_meat_info:
                response_parts = ["문의하신 상품 3가지를 알려드립니다."]
                for item in new_meat_info:
                    response_parts.append(
                        f"{item['등급']} {item['축종']} {item['부위']} 이 있습니다. "
                        f"보유재고는 {item['재고']}kg이며, kg당 {item['가격']:,}원입니다."
                    )
                response_parts.append("원하시는 상품이 있으시다면 말씀해 주세요.")

                return {
                    "messages": messages + [AIMessage(content="\n".join(response_parts))],
                    "conversation_stage": ConversationStage.MEAT_SELECTION,
                    "customer_info": customer_info,
                    "meat_selection": new_meat_info
                }

            # 3. 아무것도 매칭되지 않은 경우
            return {
                "messages": messages + [AIMessage(content="죄송합니다. 원하시는 상품을 좀 더 자세히 말씀해 주시겠습니까?")],
                "conversation_stage": ConversationStage.MEAT_SELECTION,
                "customer_info": customer_info,
                "meat_selection": meat_selection
            }
        elif current_stage == ConversationStage.SELECTION_DISAMBIGUATION:
            # 모호성 해결 단계에서의 선택 처리
            selected_item = None

            # 번호로 선택한 경우
            if last_message.isdigit():
                idx = int(last_message) - 1
                if 0 <= idx < len(meat_selection):
                    selected_item = meat_selection[idx]
            else:
                # 상세 내용으로 선택한 경우
                ambiguous_items = find_ambiguous_selections(last_message, meat_selection)
                if len(ambiguous_items) == 1:
                    selected_item = ambiguous_items[0]

            if selected_item:
                confirmation_msg = (
                    f"네, 부위 : {selected_item['부위']}, 축종 : {selected_item['축종']}, "
                    f"등급 : {selected_item['등급']} 로 준비해드릴까요?"
                )
                return {
                    "messages": messages + [AIMessage(content=confirmation_msg)],
                    "conversation_stage": ConversationStage.ORDER_CONFIRMATION,
                    "customer_info": customer_info,
                    "meat_selection": meat_selection,
                    "selected_item": selected_item,
                    "order_info": {},
                    "orders": orders
                }
            else:
                return {
                    "messages": messages + [AIMessage(content="죄송합니다. 원하시는 상품을 번호나 정확한 내용으로 다시 말씀해 주시겠습니까?")],
                    "conversation_stage": ConversationStage.SELECTION_DISAMBIGUATION,
                    "customer_info": customer_info,
                    "meat_selection": meat_selection
                }

        elif current_stage == ConversationStage.ORDER_CONFIRMATION:
            if is_positive_response(last_message):  # 변경
                if selected_item:
                    confirmation_msg = (
                        f"감사합니다. 현재 kg당 {selected_item['가격']:,}원이고 "
                        f"보유 중량은 {selected_item['재고']}kg입니다.\n"
                        f"주문하실 중량을 말씀해 주시겠습니까?"
                    )
                    return {
                        "messages": messages + [AIMessage(content=confirmation_msg)],
                        "conversation_stage": ConversationStage.WEIGHT_CONFIRMATION,
                        "customer_info": customer_info,
                        "meat_selection": meat_selection,
                        "selected_item": selected_item,
                        "order_info": order_info,
                        "orders": orders
                    }
            elif is_negative_response(last_message):  # 변경
                return {
                    "messages": messages + [AIMessage(content="죄송합니다. 다시 한 번 원하시는 상품을 말씀해 주시겠습니까?")],
                    "conversation_stage": ConversationStage.MEAT_SELECTION,
                    "customer_info": customer_info,
                    "meat_selection": meat_selection,
                    "selected_item": None
                }
            else:
                return {
                    "messages": messages + [AIMessage(content="죄송합니다. 주문을 진행하시겠습니까?")],
                    "conversation_stage": ConversationStage.ORDER_CONFIRMATION,
                    "customer_info": customer_info,
                    "meat_selection": meat_selection,
                    "selected_item": selected_item,
                    "order_info": order_info
                }

        elif current_stage == ConversationStage.WEIGHT_CONFIRMATION:
            requested_weight = extract_weight(last_message)
            if requested_weight:
                available_weight = selected_item['재고']
                price_per_kg = selected_item['가격']

                # 기존 주문 목록 가져오기
                current_orders = state.get("orders", [])

                if requested_weight <= available_weight:
                    # 즉시 주문 가능한 경우
                    total_price = round(price_per_kg * requested_weight)
                    order_info = {
                        "requested_weight": round(requested_weight, 1),
                        "type": "immediate",
                        "price_per_kg": price_per_kg,
                        "total_price": total_price,
                        "immediate_weight": round(requested_weight, 1),
                        "immediate_price": total_price,
                        "confirmed": True,
                        "selected_item": selected_item  # 선택된 상품 정보 포함
                    }

                    # 현재 주문을 orders 리스트에 추가
                    current_orders.append(order_info)

                    # 바로 주문 확정 및 추가 주문 확인 메시지
                    confirmation_msg = (
                        f"네 고객님 {requested_weight:.1f}kg 주문건 \n"
                        f"총 결제금액: {total_price:,}원입니다. "
                        f"고객님 추가주문 있으실까요?"
                    )

                    return {
                        "messages": messages + [AIMessage(content=confirmation_msg)],
                        "conversation_stage": ConversationStage.ADDITIONAL_ORDER_CONFIRMATION,
                        "customer_info": customer_info,
                        "meat_selection": None,
                        "selected_item": None,
                        "order_info": {},
                        "orders": current_orders  # 업데이트된 주문 목록
                    }

                else:
                    # 예약 주문이 필요한 경우
                    immediate_weight = available_weight
                    reservation_weight = round(requested_weight - available_weight, 1)
                    immediate_price = round(price_per_kg * immediate_weight)
                    reservation_price = round(price_per_kg * reservation_weight)
                    total_price = immediate_price + reservation_price

                    order_info = {
                        "immediate_weight": round(immediate_weight, 1),
                        "reservation_weight": round(reservation_weight, 1),
                        "type": "split",
                        "price_per_kg": price_per_kg,
                        "immediate_price": immediate_price,
                        "reservation_price": reservation_price,
                        "total_price": total_price,
                        "selected_item": selected_item,  # 선택된 상품 정보 포함
                        "confirmed": False  # 예약 주문 확인 대기
                    }

                    confirmation_msg = (
                        f"고객님, 죄송하지만 현재 보유중량은 {immediate_weight:.1f}kg으로 "
                        f"{immediate_weight:.1f}kg는 바로 주문이 가능하지만, "
                        f"{reservation_weight:.1f}kg은 예약주문만 가능합니다. "
                        f"어떻게 주문해드릴까요?"
                    )

                    return {
                        "messages": messages + [AIMessage(content=confirmation_msg)],
                        "conversation_stage": ConversationStage.RESERVATION_CONFIRMATION,
                        "customer_info": customer_info,
                        "meat_selection": meat_selection,
                        "selected_item": selected_item,
                        "order_info": order_info,  # 예약 주문 정보
                        "orders": current_orders  # 기존 주문 목록 유지
                    }
            else:
                return {
                    "messages": messages + [AIMessage(content="죄송합니다. 주문하실 중량을 숫자와 단위(kg)로 말씀해 주시겠습니까?")],
                    "conversation_stage": ConversationStage.WEIGHT_CONFIRMATION,
                    "customer_info": customer_info,
                    "meat_selection": meat_selection,
                    "selected_item": selected_item,
                    "order_info": order_info,
                    "orders": state.get("orders", [])  # 기존 주문 목록 유지
                }

        elif current_stage == ConversationStage.RESERVATION_CONFIRMATION:
            # GPT-4 기반 의도 분류기 초기화
            intent_classifier = ReservationIntentClassifier()

            # 현재 주문 상황 컨텍스트 구성
            context = {
                "immediate_weight": order_info['immediate_weight'],
                "requested_weight": order_info['immediate_weight'] + order_info['reservation_weight'],
                "price_per_kg": order_info['price_per_kg']
            }

            # 고객 의도 분류
            intent_result = intent_classifier.classify_intent(last_message, context)
            response_state = get_response_by_intent(intent_result, order_info)

            # 주문이 확정된 경우 추가 주문 확인 단계로 전환
            if response_state["order_info"].get("confirmed"):
                # 현재 주문을 orders 리스트에 추가
                current_orders = state.get("orders", [])
                current_orders.append(response_state["order_info"])

                # 추가 주문 확인 메시지 추가 (원래 응답 뒤에 추가)
                main_message = response_state["messages"][0].content
                complete_message = main_message + "\n\n고객님, 추가 주문이 있으실까요?"

                return {
                    "messages": messages + [AIMessage(content=complete_message)],
                    "conversation_stage": ConversationStage.ADDITIONAL_ORDER_CONFIRMATION,
                    "customer_info": customer_info,
                    "meat_selection": None,  # 새로운 주문을 위해 초기화
                    "selected_item": None,   # 새로운 주문을 위해 초기화
                    "order_info": {},        # 새로운 주문을 위해 초기화
                    "orders": current_orders  # 전체 주문 목록 유지
                }

            # 주문이 확정되지 않은 경우
            return {
                "messages": messages + response_state["messages"],
                "conversation_stage": response_state["conversation_stage"],
                "customer_info": customer_info,
                "meat_selection": meat_selection if response_state["conversation_stage"] != ConversationStage.MEAT_SELECTION else None,
                "selected_item": selected_item if response_state["conversation_stage"] != ConversationStage.MEAT_SELECTION else None,
                "order_info": response_state["order_info"],
                "orders": state.get("orders", [])  # 기존 주문 목록 유지
            }

        elif current_stage == ConversationStage.ADDITIONAL_ORDER_CONFIRMATION:
            if is_positive_response(last_message):
                return {
                    "messages": messages + [AIMessage(content="네, 원하시는 고기를 말씀해 주세요.")],
                    "conversation_stage": ConversationStage.MEAT_SELECTION,
                    "customer_info": customer_info,
                    "meat_selection": None,
                    "selected_item": None,
                    "order_info": {},
                    "orders": orders,
                    "delivery_method": None
                }
            elif is_negative_response(last_message):
                return {
                    "messages": messages + [AIMessage(content="""
        수령 방법을 선택해 주세요:
        1. 배송
        2. 택배
        3. 청주공장방문
        4. 영천공장방문
        5. 본사방문
                    """.strip())],
                    "conversation_stage": ConversationStage.DELIVERY_METHOD_SELECTION,
                    "customer_info": customer_info,
                    "meat_selection": None,
                    "selected_item": None,
                    "order_info": {},
                    "orders": orders,
                    "delivery_method": None
                }

        elif current_stage == ConversationStage.DELIVERY_METHOD_SELECTION:
            delivery_method = None

            # 숫자로 입력한 경우
            if last_message.isdigit():
                idx = int(last_message) - 1
                if 0 <= idx < len(DELIVERY_METHODS):
                    delivery_method = DELIVERY_METHODS[idx]
            else:
                # 직접 입력한 경우
                user_input = last_message.strip()
                for method in DELIVERY_METHODS:
                    if method in user_input:
                        delivery_method = method
                        break

            if delivery_method:
                total_price = 0
                summary_parts = [
                    "\n",
                    "="*35 + "\n",
                    f"{customer_info['상호명']} {customer_info['고객명']} 고객님 주문 내역\n\n",
                    f"수령 방법: {delivery_method}\n\n",
                    "주문 상품\n"
                ]

                for order in orders:
                    # 상품 정보 유효성 검사
                    item = order.get("selected_item", {})
                    if not item:
                        continue

                    summary_parts.append(f"\n{item.get('부위', '알 수 없음')} ({item.get('축종', '알 수 없음')}, {item.get('등급', '알 수 없음')})\n")

                    if order.get("type") == "split":  # 예약 주문이 포함된 경우
                        immediate_weight = order.get('immediate_weight', 0)
                        reservation_weight = order.get('reservation_weight', 0)
                        total_price = order.get('total_price', 0)

                        summary_parts.append(
                            f"주문 중량: {immediate_weight:.1f}kg\n"
                            f"예약 중량: {reservation_weight:.1f}kg\n"
                            f"결제 금액: {total_price:,}원\n"
                        )
                    else:  # 일반 주문의 경우
                        weight = order.get('immediate_weight', 0)
                        price = order.get('total_price', 0)

                        summary_parts.append(
                            f"주문 중량: {weight:.1f}kg\n"
                            f"결제 금액: {price:,}원\n"
                        )

                    total_price += order.get('total_price', 0)

                summary_parts.extend([
                    f"\n총 결제 금액: {total_price:,}원\n",
                    "\n\n" + "="*35 + "\n",
                    "고객님의 소중한 주문에 감사드리며,\n",
                    "일품한우 AI 상담원이 안내드렸습니다.\n"
                ])

                return {
                    "messages": messages + [AIMessage(content="".join(summary_parts))],
                    "conversation_stage": ConversationStage.INIT,
                    "customer_info": None,
                    "meat_selection": None,
                    "selected_item": None,
                    "order_info": {},
                    "orders": [],
                    "delivery_method": None
                }
            else:
                return {
                    "messages": messages + [AIMessage(content="""
        수령 방법을 선택해 주세요:
        1. 배송
        2. 택배
        3. 청주공장방문
        4. 영천공장방문
        5. 본사방문
                    """.strip())],
                    "conversation_stage": ConversationStage.DELIVERY_METHOD_SELECTION,
                    "customer_info": customer_info,
                    "meat_selection": None,
                    "selected_item": None,
                    "order_info": {},
                    "orders": orders,
                    "delivery_method": None
                }


    except Exception as e:
        logging.error(f"대화 처리 중 오류 발생: {str(e)}")
        return {
            "messages": messages + [AIMessage(content="죄송합니다. 처리 중 오류가 발생했습니다. 다시 시도해 주시겠습니까?")],
            "conversation_stage": current_stage,
            "customer_info": customer_info,
            "meat_selection": meat_selection,
            "selected_item": selected_item,
            "order_info": order_info,
            "orders": state.get("orders", [])
        }


@app.on_event("startup")
async def startup_event():
    global app_state, customer_conn, customer_cursor, hanwoo_conn, hanwoo_cursor, workflow
    try:
        # 데이터베이스 연결
        (customer_conn, customer_cursor), (hanwoo_conn, hanwoo_cursor) = init_databases()

        # Langsmith 프로젝트 생성
        project_name = "hanwoo-chatbot"
        try:
            client.create_project(project_name=project_name)
        except Exception:
            pass

        # 데이터 확인
        hanwoo_cursor.execute("SELECT * FROM hanwoo LIMIT 1")
        sample = hanwoo_cursor.fetchone()
        logging.info(f"한우 데이터 샘플: {sample}")

        # 워크플로우 설정
        workflow = StateGraph(State)
        workflow.add_node("process_conversation", process_conversation)
        workflow.add_edge(START, "process_conversation")
        workflow.add_edge("process_conversation", END)
        
        # 그래프 컴파일
        app.workflow = workflow.compile()

        # 초기 상태 설정
        app_state = {
            "messages": [],
            "conversation_stage": ConversationStage.INIT,
            "customer_info": None,
            "meat_selection": None,
            "selected_item": None,
            "order_info": {},
            "orders": [],
            "delivery_method": None
        }
        
    except Exception as e:
        logging.error(f"Startup error: {e}")
        raise e

@app.on_event("shutdown")
async def shutdown_event():
    try:
        # 최종 통계 저장
        final_statistics = analyze_conversation_history()
        logging.info("=== 최종 대화 통계 ===")
        logging.info(f"총 대화 수: {final_statistics['total_conversations']}")
        logging.info(f"평균 응답 시간: {final_statistics['average_response_time']:.2f}초")
        logging.info(f"오류율: {final_statistics['error_rate']*100:.2f}%")
        for transition, count in final_statistics['stage_transitions'].items():
            logging.info(f"상태 전환 {transition}: {count}회")
    except Exception as e:
        logging.error(f"통계 저장 중 오류 발생: {str(e)}")
    finally:
        # 데이터베이스 연결 종료
        if customer_conn:
            customer_conn.close()
        if hanwoo_conn:
            hanwoo_conn.close()

@app.post("/chat")
async def chat(chat_input: ChatInput):
    global app_state
    try:
        # 종료 요청 처리
        if chat_input.message.lower() in ['quit', '종료', 'exit']:
            statistics = analyze_conversation_history()
            return {
                "response": "채팅을 종료합니다. 감사합니다.",
                "statistics": {
                    "total_conversations": statistics['total_conversations'],
                    "average_response_time": f"{statistics['average_response_time']:.2f}초",
                    "error_rate": f"{statistics['error_rate']*100:.2f}%",
                    "transitions": statistics['stage_transitions']
                }
            }

        # 상태 업데이트
        app_state = app.workflow.invoke({
            "messages": app_state["messages"] + [HumanMessage(content=chat_input.message)],
            "conversation_stage": app_state["conversation_stage"],
            "customer_info": app_state["customer_info"],
            "meat_selection": app_state["meat_selection"],
            "selected_item": app_state.get("selected_item"),
            "order_info": app_state.get("order_info", {}),
            "orders": app_state.get("orders", [])
        })
        
        return {"response": app_state["messages"][-1].content}
        
    except Exception as e:
        logging.error(f"Error: {str(e)}")
        return {"response": "죄송합니다. 오류가 발생했습니다. 다시 시도해 주세요."}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)